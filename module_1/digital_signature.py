#!/usr/bin/env python3
"""Digital Signature Script.

This script provides digital signature generation and verification capabilities
using Elliptic Curve Digital Signature Algorithm (ECDSA). It supports various
hash algorithms and can work with ECC key pairs generated by the ecc_keygen.py script.

Features:
- Sign messages with private keys
- Verify signatures with public keys
- Support for multiple hash algorithms (SHA256, SHA384, SHA512)
- File-based message signing and verification
- Multiple signature formats (DER, raw)
- Integration with existing ECC key generation workflow
"""

from __future__ import annotations

import argparse
import base64
import hashlib
import logging
import sys
from pathlib import Path

from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec

logging.basicConfig(level=logging.INFO, format="%(message)s")

logger = logging.getLogger(__name__)

DELIMETER = "=" * 50

HASH_ALGORITHMS = {
    "sha256": hashes.SHA256(),
    "sha384": hashes.SHA384(),
    "sha512": hashes.SHA512(),
}

SIGNATURE_FORMATS = {
    "der": "DER",
    "base64": "Base64",
    "hex": "Hexadecimal",
}


def load_private_key(key_file: str | Path, password: str | None = None) -> ec.EllipticCurvePrivateKey:
    """Load a private key from file.

    :param key_file: Path to the private key file
    :param password: Optional password for encrypted private keys
    :return: Loaded private key
    :raises Exception: If key loading fails
    """
    try:
        key_path = Path(key_file)
        if not key_path.exists():
            msg = f"Private key file not found: {key_file}"
            raise FileNotFoundError(msg)  # noqa: TRY301

        with key_path.open("rb") as f:
            key_data = f.read()

        password_bytes = password.encode() if password else None
        private_key = serialization.load_pem_private_key(key_data, password=password_bytes)

        if not isinstance(private_key, ec.EllipticCurvePrivateKey):
            msg = "The loaded key is not an ECC private key"
            raise TypeError(msg)  # noqa: TRY301

    except Exception:
        logger.exception("Failed to load private key from %s", key_file)
        raise
    else:
        return private_key


def load_public_key(key_file: str | Path) -> ec.EllipticCurvePublicKey:
    """Load a public key from file.

    :param key_file: Path to the public key file
    :return: Loaded public key
    :raises Exception: If key loading fails
    """
    try:
        key_path = Path(key_file)
        if not key_path.exists():
            msg = f"Public key file not found: {key_file}"
            raise FileNotFoundError(msg)  # noqa: TRY301

        with key_path.open("rb") as f:
            key_data = f.read()

        public_key = serialization.load_pem_public_key(key_data)

        if not isinstance(public_key, ec.EllipticCurvePublicKey):
            msg = "The loaded key is not an ECC public key"
            raise TypeError(msg)  # noqa: TRY301

    except Exception:
        logger.exception("Failed to load public key from %s", key_file)
        raise
    else:
        return public_key


def sign_message(
    message: bytes,
    private_key: ec.EllipticCurvePrivateKey,
    hash_algorithm: hashes.HashAlgorithm,
    signature_format: str = "der",
) -> bytes | str:
    """Sign a message with a private key.

    :param message: The message to sign
    :param private_key: The private key to use for signing
    :param hash_algorithm: The hash algorithm to use
    :param signature_format: The signature format ("der", "base64", or "hex")
    :return: The digital signature (bytes for binary formats, str for text formats)
    :raises Exception: If signing fails
    """
    try:
        signature = private_key.sign(message, ec.ECDSA(hash_algorithm))

        if signature_format == "base64":
            # Convert to Base64 string
            signature = base64.b64encode(signature).decode("ascii")
        elif signature_format == "hex":
            # Convert to hexadecimal string
            signature = signature.hex()

    except Exception:
        logger.exception("Failed to sign message")
        raise

    else:
        return signature


def verify_signature(
    message: bytes,
    signature: bytes | str,
    public_key: ec.EllipticCurvePublicKey,
    hash_algorithm: hashes.HashAlgorithm,
    signature_format: str = "der",
) -> bool:
    """Verify a digital signature.

    :param message: The original message
    :param signature: The signature to verify (bytes or str depending on format)
    :param public_key: The public key to use for verification
    :param hash_algorithm: The hash algorithm used for signing
    :param signature_format: The signature format ("der", "base64", or "hex")
    :return: True if signature is valid, False otherwise
    """
    try:
        # Convert text formats back to bytes
        if signature_format == "base64":
            signature = base64.b64decode(signature)
        elif signature_format == "hex":
            signature = bytes.fromhex(signature)

        public_key.verify(signature, message, ec.ECDSA(hash_algorithm))

    except InvalidSignature:
        return False
    except Exception:
        logger.exception("Failed to verify signature")
        return False

    else:
        return True


def save_signature(signature: bytes | str, output_file: str | Path, format_type: str = "der") -> None:
    """Save signature to file.

    :param signature: The signature to save (bytes or str depending on format)
    :param output_file: Path to save the signature
    :param format_type: The format type for display purposes
    """
    try:
        output_path = Path(output_file)

        # Determine if we need text or binary mode
        if format_type in ("base64", "hex"):
            with output_path.open("w", encoding="utf-8") as f:
                f.write(signature)
            signature_size = len(signature)
        else:
            with output_path.open("wb") as f:
                f.write(signature)
            signature_size = len(signature)

        logger.info("Signature saved to: %s", output_file)
        logger.info("Signature format: %s", format_type.upper())
        logger.info(
            "Signature size: %d %s",
            signature_size,
            "characters" if format_type in ("base64", "hex") else "bytes",
        )

    except Exception:
        logger.exception("Failed to save signature to %s", output_file)
        raise


def load_signature(signature_file: str | Path, signature_format: str = "der") -> bytes | str:
    """Load signature from file.

    :param signature_file: Path to the signature file
    :param signature_format: The signature format to determine how to read the file
    :return: The signature (bytes or str depending on format)
    """
    try:
        sig_path = Path(signature_file)
        if not sig_path.exists():
            msg = f"Signature file not found: {signature_file}"
            raise FileNotFoundError(msg)  # noqa: TRY301

        if signature_format in ("base64", "hex"):
            with sig_path.open("r", encoding="utf-8") as f:
                return f.read().strip()
        else:
            with sig_path.open("rb") as f:
                return f.read()

    except Exception:
        logger.exception("Failed to load signature from %s", signature_file)
        raise


def display_signature_info(signature: bytes | str, format_type: str) -> None:
    """Display signature information.

    :param signature: The signature (bytes or str depending on format)
    :param format_type: The signature format
    """
    logger.info("Signature Information:")
    logger.info("  Format: %s", format_type.upper())

    if format_type in ("base64", "hex"):
        logger.info("  Size: %d characters", len(signature))
        logger.info("  Value: %s", signature)
    else:  # der format
        logger.info("  Size: %d bytes", len(signature))
        logger.info("  Hex: %s", signature.hex())


def get_message_hash(message: bytes, hash_algorithm: str) -> bytes:
    """Get the hash of a message using the specified algorithm.

    :param message: The message to hash
    :param hash_algorithm: The hash algorithm name
    :return: The message hash
    """
    match hash_algorithm:
        case "sha256":
            return hashlib.sha256(message).digest()
        case "sha384":
            return hashlib.sha384(message).digest()
        case "sha512":
            return hashlib.sha512(message).digest()
        case _:
            msg = f"Unsupported hash algorithm: {hash_algorithm}"
            raise ValueError(msg)


def parse_arguments() -> tuple[argparse.Namespace, argparse.ArgumentParser]:
    """Parse command line arguments.

    :return: Tuple of (parsed arguments, parser instance)
    """
    parser = argparse.ArgumentParser(
        description="Digital signature generation and verification using ECDSA",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Sign a message with a private key
  python digital_signature.py sign -m "Hello, World!" -k private_key.pem

  # Sign a file
  python digital_signature.py sign -f message.txt -k private_key.pem

  # Verify a signature
  python digital_signature.py verify -m "Hello, World!" -s signature.der -p public_key.pem

  # Sign with SHA384
  python digital_signature.py sign -m "Hello, World!" -k private_key.pem -a sha384

  # Sign and save in Base64 format (human-readable)
  python digital_signature.py sign -m "Hello, World!" -k private_key.pem --format base64

  # Sign and save in hexadecimal format
  python digital_signature.py sign -m "Hello, World!" -k private_key.pem --format hex

  # Verify with specific hash algorithm
  python digital_signature.py verify -m "Hello, World!" -s signature.der -p public_key.pem -a sha384

  # Verify Base64 signature
  python digital_signature.py verify -m "Hello, World!" -s signature.txt -p public_key.pem --format base64

  # Sign with password-protected private key
  python digital_signature.py sign -m "Hello, World!" -k private_key.pem -w mypassword

Available Hash Algorithms:
  - sha256: SHA-256 (default, widely used)
  - sha384: SHA-384 (higher security)
  - sha512: SHA-512 (highest security)

Signature Formats:
  - der: DER-encoded signature (default, standard format)
  - base64: Base64-encoded signature (human-readable)
  - hex: Hexadecimal-encoded signature (human-readable)
        """,
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Sign command
    sign_parser = subparsers.add_parser("sign", help="Sign a message or file")
    sign_parser.add_argument("-m", "--message", help="Message to sign (if not using file)")
    sign_parser.add_argument("-f", "--file", help="File to sign (if not using message)")
    sign_parser.add_argument("-k", "--private-key", required=True, help="Path to private key file")
    sign_parser.add_argument("-w", "--password", help="Password for encrypted private key")
    sign_parser.add_argument(
        "-a",
        "--algorithm",
        choices=list(HASH_ALGORITHMS.keys()),
        default="sha256",
        help="Hash algorithm to use (default: sha256)",
    )
    sign_parser.add_argument(
        "-o",
        "--output",
        help="Output file for signature (default: signature.{format})",
    )
    sign_parser.add_argument(
        "--format",
        choices=list(SIGNATURE_FORMATS.keys()),
        default="der",
        help="Signature format (default: der)",
    )
    sign_parser.add_argument("--display", action="store_true", help="Display signature information")

    # Verify command
    verify_parser = subparsers.add_parser("verify", help="Verify a signature")
    verify_parser.add_argument("-m", "--message", help="Original message (if not using file)")
    verify_parser.add_argument("-f", "--file", help="Original file (if not using message)")
    verify_parser.add_argument("-s", "--signature", required=True, help="Path to signature file")
    verify_parser.add_argument("-p", "--public-key", required=True, help="Path to public key file")
    verify_parser.add_argument(
        "-a",
        "--algorithm",
        choices=list(HASH_ALGORITHMS.keys()),
        default="sha256",
        help="Hash algorithm used for signing (default: sha256)",
    )
    verify_parser.add_argument(
        "--format",
        choices=list(SIGNATURE_FORMATS.keys()),
        default="der",
        help="Signature format (default: der)",
    )
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output")
    return parser.parse_args(), parser


def handle_sign_command(args: argparse.Namespace) -> None:
    """Handle the sign command."""
    if not args.message and not args.file:
        logger.error("Either --message or --file must be specified")
        sys.exit(1)

    if args.message and args.file:
        logger.error("Cannot specify both --message and --file")
        sys.exit(1)

    if args.message:
        message = args.message.encode("utf-8")
        logger.info("Signing message: %s", args.message)
    else:
        message_path = Path(args.file)
        if not message_path.exists():
            logger.error("File not found: %s", args.file)
            sys.exit(1)
        with message_path.open("rb") as f:
            message = f.read()
        logger.info("Signing file: %s (%d bytes)", args.file, len(message))

    logger.info("Loading private key from: %s", args.private_key)
    private_key = load_private_key(args.private_key, args.password)
    logger.info("✓ Private key loaded successfully")

    hash_algorithm = HASH_ALGORITHMS[args.algorithm]
    logger.info("Using hash algorithm: %s", args.algorithm.upper())

    signature_format = args.format
    logger.info("Using signature format: %s", signature_format.upper())

    logger.info("Signing message...")
    signature = sign_message(message, private_key, hash_algorithm, signature_format)
    logger.info("✓ Message signed successfully")

    if args.display:
        display_signature_info(signature, signature_format)

    output_file = args.output if args.output else f"signature.{signature_format}"
    save_signature(signature, output_file, signature_format)


def handle_verify_command(args: argparse.Namespace) -> None:
    """Handle the verify command."""
    # Validate input
    if not args.message and not args.file:
        logger.error("Either --message or --file must be specified")
        sys.exit(1)

    if args.message and args.file:
        logger.error("Cannot specify both --message and --file")
        sys.exit(1)

    # Get message content
    if args.message:
        message = args.message.encode("utf-8")
        logger.info("Verifying signature for message: %s", args.message)
    else:
        message_path = Path(args.file)
        if not message_path.exists():
            logger.error("File not found: %s", args.file)
            sys.exit(1)
        with message_path.open("rb") as f:
            message = f.read()
        logger.info("Verifying signature for file: %s (%d bytes)", args.file, len(message))

    # Load public key
    logger.info("Loading public key from: %s", args.public_key)
    public_key = load_public_key(args.public_key)
    logger.info("✓ Public key loaded successfully")

    # Get signature format
    signature_format = args.format
    logger.info("Using signature format: %s", signature_format.upper())

    # Load signature
    logger.info("Loading signature from: %s", args.signature)
    signature = load_signature(args.signature, signature_format)
    logger.info("✓ Signature loaded successfully")

    # Get hash algorithm
    hash_algorithm = HASH_ALGORITHMS[args.algorithm]
    logger.info("Using hash algorithm: %s", args.algorithm.upper())

    # Verify signature
    logger.info("Verifying signature...")
    is_valid = verify_signature(message, signature, public_key, hash_algorithm, signature_format)

    if is_valid:
        logger.info("✓ SIGNATURE VERIFICATION SUCCESSFUL")
        logger.info("The signature is valid and authenticates the message.")
    else:
        logger.error("✗ SIGNATURE VERIFICATION FAILED")
        logger.error("The signature is invalid or the message has been tampered with.")
        sys.exit(1)


def main() -> None:
    """Execute the digital signature application."""
    args, parser = parse_arguments()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    if not args.command:
        logger.error("No command specified. Use 'sign' or 'verify'.")
        parser.print_help()
        sys.exit(1)

    logger.info("Digital Signature Tool")
    logger.info(DELIMETER)

    try:
        if args.command == "sign":
            handle_sign_command(args)
        elif args.command == "verify":
            handle_verify_command(args)

        logger.info(DELIMETER)
        logger.info("SUCCESS: Digital signature operation completed!")

    except Exception:
        logger.exception("Error")
        if args.verbose:
            logger.exception("Full error details:")
        sys.exit(1)


if __name__ == "__main__":
    main()
